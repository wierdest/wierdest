#!/usr/bin/env node
const app = require('../app');
const debug = require('debug')('wierdest:server');
const http = require('http');
const { Server } = require('socket.io');
const uuid = require('uuid');
const { startGameLoop, stopGameLoop } = require('./game-logic');
// Create HTTP server
const server = http.createServer(app);

// Create the Socket.IO server
const io = new Server(server, {
  cors: {
    origin: "*", // Allow all origins (adjust as needed for security)
    methods: ["GET", "POST"],
    credentials: true // Allow credentials (cookies)
  }
});


// Namespaces @ https://socket.io/docs/v4/namespaces/
const lobbyNamespace = io.of("/game/lobby");
const oneVsOneNamespace = io.of("/game/play/1vs1")
const twoVsTwoNamespace = io.of("/game/play/2vs2")

// store all the users in the lobby
const userStore = {}
// Lobby namespace
lobbyNamespace.on('connection', (socket) => {
  // Generate and store the user ID in the socket object
  userId = uuid.v4();
  userStore[userId] = socket;
  updatePlayersList(); // Update the list of players
  console.log(`Lobby user connected with ID ${userId}, socket ID ${socket.id}`);
  // Send the userId to the client
  socket.emit('lobbyInit', { userId });

  socket.on('disconnect', () => {
    console.log('Lobby user disconnected');
    delete userStore[userId];
    updatePlayersList(); // Update the list of players
  });
});

function updatePlayersList() {
  const players = Object.keys(userStore).map(userId => ({ userId }));
  lobbyNamespace.emit('updatePlayersList', players);
}

// Game namespace initiation values

// Initialize an empty object to store player data
const oneVsOnePlayers = {};
const oneVsOneSpectators = {};

// Hard-coded player radius, should come from client, right?
const playerRadius = 10;
// Hard-coded width and height, same as player
const boardWidth = 600;
const boardHeight = 500;
// Array to store the "bullets"
const projectiles = [];

let activeOneVsOnePlayers = 0;

// One vs One Game Play Namespace
oneVsOneNamespace.on('connection', (socket) => {

  const userId = socket.handshake.query.userId;

  if (!userId) {
    console.error(`No userId provided for gameNamespace connection, socket ID ${socket.id}`);
    socket.disconnect();
    return;
  }
  console.log('Game user connected with ID ', userId)

  // Check if there are already two active players
  if(activeOneVsOnePlayers >= 2) {
    // Treat as a spectator
    console.log(`User ${userId} joined as spectator.`);
    oneVsOneSpectators[userId] = socket;

    // To avoid deep recursion errors, pass the spectatorsIds only
    const spectatorsIds = Object.keys(oneVsOneSpectators);
    oneVsOneNamespace.emit('updateSpectators', spectatorsIds);

    socket.emit('spectatorMode', {message: 'You are a spectator. Wait for the match to be over!'})
    // Broadcast current player data and projectiles to the spectator
    socket.emit('updatePlayers', oneVsOnePlayers);
    socket.emit('updateProjectiles', projectiles);



    // Handle spectator disconnection
    socket.on('disconnect', () => {
      console.log(`Spectator ${userId} disconnected.`);
      delete oneVsOneSpectators[userId];
    });

    return;
  }
  // Treat like a player
  // If there is room, player becomes active
  console.log(`User ${userId} joined as a player.`);
  
  // Increment active player count when a player connects
  activeOneVsOnePlayers++;

  // Start the game loop if this is the first player
  startGameLoop(oneVsOnePlayers, projectiles, playerRadius, boardWidth, boardHeight, oneVsOneNamespace);

  // Send 'init' event with userId
  // do we really need to emit this?
  socket.emit('gameInit', { userId });

  // Initialize player data for the new connection
  oneVsOnePlayers[userId] = { pos: { x: 0, y: 0 }, rotation: 0 };

  // Broadcast current player data to the new connection
  socket.emit('updatePlayers', oneVsOnePlayers);

  // Broadcast current projectiles data to the new connection
  socket.emit('updateProjectiles', projectiles);

  // Listen for 'update' events from clients
  socket.on('update', (data) => {
    if (oneVsOnePlayers[userId]) {
      oneVsOnePlayers[userId].pos = data.pos;
      oneVsOnePlayers[userId].rotation = data.rotation;
      // Broadcast updated player data to all clients
      oneVsOneNamespace.emit('updatePlayers', oneVsOnePlayers); 
    }
  });

  // Listen to 'fire' events 
  socket.on('fire', (proj) => {
    // console.log('received fire event ', proj)
    projectiles.push({ ...proj, id: uuid.v4(), ownerId: userId });
    // Broadcast updated projectile data to all cliente
    oneVsOneNamespace.emit('updateProjectiles', projectiles);
  });

  // Handle user disconnection
  socket.on('disconnect', () => {
    console.log(`User ${userId} disconnected`);
    delete oneVsOnePlayers[userId];
    oneVsOneNamespace.emit('updatePlayers', oneVsOnePlayers);

    const filteredProjectiles = projectiles.filter(proj => proj.ownerId !== userId);
    // Update the original array
    projectiles.length = 0;
    projectiles.push(...filteredProjectiles);
    oneVsOneNamespace.emit('updateProjectiles', projectiles);

    // Decrement the active player count
    activeOneVsOnePlayers--;
    // If there are spectators, promote the first spectator to player
    if(Object.keys(oneVsOneSpectators).length > 0) {
      const nextUserId = Object.keys(oneVsOneSpectators)[0];
      const nextSocket = oneVsOneSpectators[nextUserId];

      // remove spectator
      delete oneVsOneSpectators[nextUserId];
      // add player
      oneVsOnePlayers[nextUserId] =  { pos : { x: 0, y: 0 }, rotation: 0 };
      nextSocket.emit('gameInit', { userId: nextUserId });
      oneVsOneNamespace.emit('updatePlayers', oneVsOnePlayers);

      activeOneVsOnePlayers++;
    }
    // Stop the game loop if no players are connected
    stopGameLoop(activeOneVsOnePlayers);

  });
});

// Start the server
server.listen(process.env.PORT || 3000, () => {
  console.log(`Server running on http://localhost:${server.address().port}`);
});

debug('Server is configured');

module.exports = server;
