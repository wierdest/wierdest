#!/usr/bin/env node
const app = require('../app');
const debug = require('debug')('wierdest:server');
const http = require('http');
const { Server } = require('socket.io');
const uuid = require('uuid');

// Create HTTP server
const server = http.createServer(app);

// Create the Socket.IO server
const io = new Server(server, {
  cors: {
    origin: "*", // Allow all origins (adjust as needed for security)
    methods: ["GET", "POST"]
  }
});

// Namespaces @ https://socket.io/docs/v4/namespaces/
const lobbyNamespace = io.of("/game//lobby");
const gameNamespace = io.of("/game/play")

// Initialize an empty object to store player data
const players = {};

// Hard-coded player radius, should come from client, right?
const playerRadius = 10;

// Hard-coded width and height, same as player
const boardWidth = 600;
const boardHeight = 500;


// Array to store the "bullets"
const projectiles = [];

const projectileSpeed = 5;

function moveAndCleanProjectiles() {
  for (let i = projectiles.length - 1; i >= 0; i--) {
    const proj = projectiles[i];
    proj.pos.x += Math.cos(proj.rotation) * projectileSpeed;
    proj.pos.y += Math.sin(proj.rotation) * projectileSpeed;

    // Hardcoded the canvas size! todo fix this
    if (proj.pos.x < 0 || proj.pos.x > boardWidth || proj.pos.y < 0 || proj.pos.y > boardHeight) {
      projectiles.splice(i, 1); // Remove the projectile
    }
  }
}

function dealWithDeaths() {
  // Checks and deals with deaths by collision with bullets 
  // Iterate over the projectiles, from the last to the first 
  for(let i = projectiles.length - 1; i >= 0; i--) {
    // Get a projectile
    const proj = projectiles[i];
    const projOwner = proj.ownerId;

    // Iterate over the players
    Object.keys(players).forEach(playerId => {
      // Select a player
      const player = players[playerId];
      
      // Measure distance between player and projectile
      const distance = Math.hypot(proj.pos.x - player.pos.x, proj.pos.y - player.pos.y);

      // Poderia usar a formula euclidiana, mas acho que  Math.hypot parece mais performático?
      // Raiz quadrada de (x2 - x1) ao quadrado + (y2 - y1) ao quadrado
      // const distance = Math.sqrt(
      //   Math.pow(proj.pos.x - player.pos.x, 2) + Math.pow(proj.pos.y - player.pos.y, 2)
      // );

      // Check if a distancia entre esses pontos é menor do que o player
      if(distance < playerRadius) {
        if(projOwner === playerId) {
          // Player got hit by their own bullet
          console.log(`Player ${playerId} committed suicide`);
          gameNamespace.emit('suicide', { playerId });
        } else {
          console.log(`Player ${playerId} was killed by ${projOwner}`);
          gameNamespace.emit('killed', { killedId: playerId, killerId: projOwner });
        }

        // Remove o projetil
        projectiles.splice(i, 1);
        // creio que não precise emitir o array, já que é feito no loop
        // io.emit('updateProjectiles', projectiles);

      }
    })
  }
}

function dealWithPlayerCollisions() {
  // Checks player to player collision
  const playerIds = Object.keys(players);
  // Iterate over the players in a 2d loop
  for(let i = 0; i < playerIds.length; i++) {

    for(let j = i + 1; j < playerIds.length; j++) {
      // Get player A and player B
      const playerA = players[playerIds[i]];
      const playerB = players[playerIds[j]];

      const distance = Math.hypot(
        playerA.pos.x - playerB.pos.x,
        playerA.pos.y - playerB.pos.y
      );

      // Hardcoded player radius

      if(distance < playerRadius * 2) {
        // Detected collision   
        // Previne que um jogador fique por cima do outro (overlap), atualizando a posição
        const overlap = (playerRadius * 2) - distance;

        // Calculate displacement to resolve the collision
        const dx = (playerB.pos.x - playerA.pos.x) / distance;
        const dy = (playerB.pos.y - playerA.pos.y) / distance;

        // Adjust positions to resolve collision
        playerA.pos.x -= dx * overlap / 2;
        playerA.pos.y -= dy * overlap / 2;
        playerB.pos.x += dx * overlap / 2;
        playerB.pos.y += dy * overlap / 2;
      }
    }
  }
}

// Game Init
gameNamespace.on('connection', (socket) => {
  // Generate a unique user ID
  const userId = uuid.v4();
  console.log('User connected with ID', userId);

  // Send 'init' event with userId
  // do we really need to emit this?
  socket.emit('init', { userId });

  // Initialize player data for the new connection
  players[userId] = { pos: { x: 0, y: 0 }, rotation: 0 };

  // Broadcast current player data to the new connection
  gameNamespace.emit('updatePlayers', players);

  // Broadcast current projectiles data to the new connection
  gameNamespace.emit('updateProjectiles', projectiles);

  // Listen for 'update' events from clients
  socket.on('update', (data) => {
    if (players[userId]) {
      players[userId].pos = data.pos;
      players[userId].rotation = data.rotation; 
      gameNamespace.emit('updatePlayers', players); // Broadcast updated player data to all clients
    }
  });

  // Listen to 'fire' events 
  socket.on('fire', (proj) => {
    // console.log('received fire event ', proj)
    projectiles.push({ ...proj, id: uuid.v4(), ownerId: userId });
    gameNamespace.emit('updateProjectiles', projectiles);
  });

  // Handle user disconnection
  socket.on('disconnect', () => {
    console.log(`User ${userId} disconnected`);
    delete players[userId]; 
    gameNamespace.emit('updatePlayers', players);

    const filteredProjectiles = projectiles.filter(proj => proj.ownerId !== userId);
    // Update the original array
    projectiles.length = 0;
    projectiles.push(...filteredProjectiles);
    gameNamespace.emit('updateProjectiles', projectiles);
  });
});


// Server side Game Loop 
setInterval(() => {
  dealWithPlayerCollisions();
  moveAndCleanProjectiles();
  dealWithDeaths();
  gameNamespace.emit('updateProjectiles', projectiles); // Broadcast updated projectiles to all clients
}, 1000 / 60); // 60 fps lol !

// Start the server
server.listen(process.env.PORT || 3000, () => {
  console.log(`Server running on http://localhost:${server.address().port}`);
});

debug('Server is configured');

module.exports = server;
